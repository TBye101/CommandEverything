<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-us" xml:lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
      <meta name="copyright" content="(C) Copyright 2005"></meta>
      <meta name="DC.rights.owner" content="(C) Copyright 2005"></meta>
      <meta name="DC.Type" content="concept"></meta>
      <meta name="DC.Title" content="NVIDIA CUDA Video Decoder"></meta>
      <meta name="abstract" content="The API reference guide for the CUDA video decoder."></meta>
      <meta name="description" content="The API reference guide for the CUDA video decoder."></meta>
      <meta name="DC.Coverage" content="Programming Guides"></meta>
      <meta name="DC.subject" content="Decoder, Decoder support, Decoder playback pipeline, Decoder function entry points, Decoder creation, Decoder surfaces, Decoder process frames, Decoder performance optimiziation, Decoder display frames, Decoder API support"></meta>
      <meta name="keywords" content="Decoder, Decoder support, Decoder playback pipeline, Decoder function entry points, Decoder creation, Decoder surfaces, Decoder process frames, Decoder performance optimiziation, Decoder display frames, Decoder API support"></meta>
      <meta name="DC.Format" content="XHTML"></meta>
      <meta name="DC.Identifier" content="abstract"></meta>
      <link rel="stylesheet" type="text/css" href="../common/formatting/commonltr.css"></link>
      <link rel="stylesheet" type="text/css" href="../common/formatting/site.css"></link>
      <title>Video Decoder :: CUDA Toolkit Documentation</title>
      <!--[if lt IE 9]>
      <script src="../common/formatting/html5shiv-printshiv.min.js"></script>
      <![endif]-->
      <script type="text/javascript" charset="utf-8" src="../common/scripts/tynt/tynt.js"></script>
      <script type="text/javascript" charset="utf-8" src="../common/formatting/jquery.min.js"></script>
      <script type="text/javascript" charset="utf-8" src="../common/formatting/jquery.ba-hashchange.min.js"></script>
      <script type="text/javascript" charset="utf-8" src="../common/formatting/jquery.scrollintoview.min.js"></script>
      <script type="text/javascript" src="../search/htmlFileList.js"></script>
      <script type="text/javascript" src="../search/htmlFileInfoList.js"></script>
      <script type="text/javascript" src="../search/nwSearchFnt.min.js"></script>
      <script type="text/javascript" src="../search/stemmers/en_stemmer.min.js"></script>
      <script type="text/javascript" src="../search/index-1.js"></script>
      <script type="text/javascript" src="../search/index-2.js"></script>
      <script type="text/javascript" src="../search/index-3.js"></script>
      <link rel="canonical" href="http://docs.nvidia.com/cuda/video-decoder/index.html"></link>
      <link rel="stylesheet" type="text/css" href="../common/formatting/qwcode.highlight.css"></link>
   </head>
   <body>
      
      <header id="header"><span id="company">NVIDIA</span><span id="site-title">CUDA Toolkit Documentation</span><form id="search" method="get" action="search">
            <input type="text" name="search-text"></input><fieldset id="search-location">
               <legend>Search In:</legend>
               <label><input type="radio" name="search-type" value="site"></input>Entire Site</label>
               <label><input type="radio" name="search-type" value="document"></input>Just This Document</label></fieldset>
            <button type="reset">clear search</button>
            <button id="submit" type="submit">search</button></form>
      </header>
      <div id="site-content">
         <nav id="site-nav">
            <div class="category closed"><a href="../index.html" title="The root of the site.">CUDA Toolkit
                  v8.0</a></div>
            <div class="category"><a href="index.html" title="Video Decoder">Video Decoder</a></div>
            <ul>
               <li>
                  <div class="section-link"><a href="#overview">1.&nbsp;Overview</a></div>
               </li>
               <li>
                  <div class="section-link"><a href="#video-decode">2.&nbsp;Video Decode</a></div>
                  <ul>
                     <li>
                        <div class="section-link"><a href="#mpeg-2-vc-1-support">2.1.&nbsp;MPEG-2/VC-1 Support</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="#h264-avchd-support">2.2.&nbsp;H.264/AVCHD Support</a></div>
                     </li>
                  </ul>
               </li>
               <li>
                  <div class="section-link"><a href="#introduction">3.&nbsp;Introduction</a></div>
               </li>
               <li>
                  <div class="section-link"><a href="#cuda-video-decoder">4.&nbsp;CUDA Video Decoder</a></div>
                  <ul>
                     <li>
                        <div class="section-link"><a href="#decoder-creation">4.1.&nbsp;Decoder Creation</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="#decoding-surfaces">4.2.&nbsp;Decoding Surfaces</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="#processing-and-displaying-frames">4.3.&nbsp;Processing and Displaying Frames</a></div>
                     </li>
                     <li>
                        <div class="section-link"><a href="#performance-optimizations-for-video-decoding">4.4.&nbsp;Performance Optimizations for Video Decoding</a></div>
                     </li>
                  </ul>
               </li>
            </ul>
         </nav>
         <div id="resize-nav"></div>
         <nav id="search-results">
            <h2>Search Results</h2>
            <ol></ol>
         </nav>
         
         <div id="contents-container">
            <div id="breadcrumbs-container">
               <div id="release-info">Video Decoder
                  (<a href="../../pdf/CUDA_Video_Decoder.pdf">PDF</a>)
                  -
                  
                  v8.0
                  (<a href="https://developer.nvidia.com/cuda-toolkit-archive">older</a>)
                  -
                  Last updated January 11, 2017
                  -
                  <a href="mailto:cudatools@nvidia.com?subject=CUDA Toolkit Documentation Feedback: Video Decoder">Send Feedback</a>
                  -
                  <span class="st_facebook"></span><span class="st_twitter"></span><span class="st_linkedin"></span><span class="st_reddit"></span><span class="st_slashdot"></span><span class="st_tumblr"></span><span class="st_sharethis"></span></div>
            </div>
            <article id="contents">
               <div class="topic nested0" id="abstract"><a name="abstract" shape="rect">
                     <!-- --></a><h2 class="title topictitle1"><a href="#abstract" name="abstract" shape="rect">NVIDIA CUDA Video Decoder</a></h2>
                  <div class="body conbody"></div>
               </div>
               <div class="topic concept nested0" id="overview"><a name="overview" shape="rect">
                     <!-- --></a><h2 class="title topictitle1"><a href="#overview" name="overview" shape="rect">1.&nbsp;Overview</a></h2>
                  <div class="body conbody">
                     <p class="p">The CUDA Video Decoder API gives developers access to hardware video decoding
                        capabilities on NVIDIA GPU. The actual hardware decode can run on either Video Processor
                        (<dfn class="term">VP</dfn>) or CUDA hardware, depending on the hardware capabilities and the
                        codecs. This API supports the following video stream formats for Linux and Windows
                        platforms: MPEG-2, VC-1, and H.264 (<dfn class="term">AVCHD</dfn>). 
                     </p>
                     <p class="p">Applications can decode video streams on the GPU into Video Memory, and also apply a post
                        processing stage on the uncompressed video surfaces with CUDA. CUDA supports I/O
                        transfers of video surfaces to system memory using CUDA’s fast asynchronous uploads and
                        read-backs. For display, CUDA supports native graphics interoperability, enabling the
                        application to render the video generated surfaces using a 3D API such as OpenGL
                        (Windows and Linux) or DirectX (Windows platforms).
                     </p>
                  </div>
               </div>
               <div class="topic concept nested0" id="video-decode"><a name="video-decode" shape="rect">
                     <!-- --></a><h2 class="title topictitle1"><a href="#video-decode" name="video-decode" shape="rect">2.&nbsp;Video Decode</a></h2>
                  <div class="body conbody">
                     <p class="p"></p>
                  </div>
                  <div class="topic concept nested1" id="mpeg-2-vc-1-support"><a name="mpeg-2-vc-1-support" shape="rect">
                        <!-- --></a><h3 class="title topictitle2"><a href="#mpeg-2-vc-1-support" name="mpeg-2-vc-1-support" shape="rect">2.1.&nbsp;MPEG-2/VC-1 Support</a></h3>
                     <div class="body conbody">
                        <ul class="ul">
                           <li class="li">Decode Acceleration for G8x, G9x (Requires Compute 1.1 or higher)</li>
                           <li class="li">Full Bitstream Decode for MCP79, MCP89, G98, GT2xx, GF1xx, GK1xx</li>
                           <li class="li">MPEG-2 CUDA accelerated decode with a GPU with 8+ SMs (64 CUDA
                              cores) (Windows)
                           </li>
                           <li class="li">Supports HD (1080i/p) playback including Blu-ray
                              Disc™ content
                           </li>
                           <li class="li"> R185+ (Windows), R260+ (Linux)</li>
                        </ul>
                     </div>
                  </div>
                  <div class="topic concept nested1" id="h264-avchd-support"><a name="h264-avchd-support" shape="rect">
                        <!-- --></a><h3 class="title topictitle2"><a href="#h264-avchd-support" name="h264-avchd-support" shape="rect">2.2.&nbsp;H.264/AVCHD Support</a></h3>
                     <div class="body conbody">
                        <ul class="ul">
                           <li class="li">Baseline, Main, and High Profile, up to Level 4.1</li>
                           <li class="li">Full Bitstream Decoding in hardware including HD (1080i/p) Bluray
                              content
                           </li>
                           <li class="li">Supports B-Frames, bitrates up to 45 mbps</li>
                           <li class="li">Available on NVIDIA GPUs: G8x, G9x, MCP79, MCP89, G98, GT2xx, GF1xx,
                              GK1xx
                           </li>
                           <li class="li">R185+ (Windows), R260+ (Linux)</li>
                        </ul>
                     </div>
                  </div>
               </div>
               <div class="topic concept nested0" id="introduction"><a name="introduction" shape="rect">
                     <!-- --></a><h2 class="title topictitle1"><a href="#introduction" name="introduction" shape="rect">3.&nbsp;Introduction</a></h2>
                  <div class="body conbody">
                     <p class="p">This CUDA Video Decoder API allows developers access the video decoding features of
                        NVIDIA graphics hardware. This OS platform independent API is an extension to NVIDIA’s
                        CUDA technology.
                     </p>
                     <p class="p">The CUDA Video Decoder API is based on CUDA, it inherits all of CUDA’s interoperability
                        capabilities with OpenGL, Direct3D, and the CUDA support for fast memory copies between
                        video memory and system memory. It is now possible to implement a video playback
                        pipeline from video decode to image post-processing with CUDA all running entirely on
                        the GPU. With transcode applications, this API allows the video bitstream decode to be
                        fully offloaded to the GPU’s video processor. The decoded frames can be passed to a CUDA
                        accelerated video encoding stage through your GPU accelerated encoder or the NVIDIA CUDA
                        encoder.
                     </p>
                     <div class="p">The NVIDIA CUDA Samples application (windows only) implements the following playback
                        pipeline: 
                        <ol class="ol">
                           <li class="li">Parse the Video input Source (using CUDA Video Decoder API)</li>
                           <li class="li">Decode Video on GPU using <dfn class="term">NVCUVID</dfn> API.
                           </li>
                           <li class="li">Convert decoded surface (<dfn class="term">NV12</dfn> format or <dfn class="term">YUV 4:2:0</dfn>
                              format) to <dfn class="term">RGBA</dfn>.
                           </li>
                           <li class="li">Map RGBA surface to DirectX 9.0 or OpenGL surface.</li>
                           <li class="li">Draw texture to screen.</li>
                        </ol>
                     </div>
                     <p class="p">This document will focus on the use of the CUDA Video Decoder API and the stages
                        following decode, (i.e. format conversion and display using DirectX or OpenGL). Parsing
                        of the video source using the NVCUVID API is secondary to the sample, as we believe most
                        developers will already have code for parsing video streams down to the slice-level.
                        Note: The low level decode APIs are supported on both Linux and Windows platforms. The
                        NVCUVID APIs for <dfn class="term">Parsing</dfn> and <dfn class="term">Source Stream</dfn> input are available
                        only on Windows platforms.
                     </p>
                  </div>
               </div>
               <div class="topic concept nested0" id="cuda-video-decoder"><a name="cuda-video-decoder" shape="rect">
                     <!-- --></a><h2 class="title topictitle1"><a href="#cuda-video-decoder" name="cuda-video-decoder" shape="rect">4.&nbsp;CUDA Video Decoder</a></h2>
                  <div class="body conbody">
                     <p class="p">The CUDA Video Decode API consists of a header-file:
                        <samp class="ph codeph">cuviddec.h</samp> and <samp class="ph codeph">nvcuvid.h</samp> lib-file:
                        <samp class="ph codeph">nvcuvid.lib</samp> located in CUDA toolkit include files
                        location. The Windows DLLs <samp class="ph codeph">nvcuvid.dll</samp> ship with NVIDIA
                        display drivers. The Linux <samp class="ph codeph">libnvcuvid.so</samp> is included
                        with Linux drivers (R260+).
                     </p>
                     <p class="p">This API defines five function entry points for decoder creation and use:</p><pre xml:space="preserve"><span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-comment">// Create/Destroy the decoder object</span>
CUresult cuvidCreateDecoder(CUvideodecoder *phDecoder,
                            CUVIDDECODECREATEINFO *pdci);

CUresult cuvidDestroyDecoder(CUvideodecoder hDecoder);

<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-comment">// Decode a single picture (field or frame)</span>

CUresult cuvidDecodePicture(CUvideodecoder hDecoder,
                            CUVIDPICPARAMS *pPicParams);

<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-comment">// Post-process and map a video frame for use in cuda</span>
CUresult cuvidMapVideoFrame(CUvideodecoder hDecoder, <span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-keyword">int</span> nPicIdx,
                            CUdeviceptr *pDevPtr, <span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-keyword">unsigned</span> <span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-keyword">int</span> *pPitch,
                            CUVIDPROCPARAMS *pVPP);

<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-comment">// Unmap a previously mapped video frame</span>
CUresult cuvidUnmapVideoFrame(CUvideodecoder hDecoder, CUdeviceptr DevPtr);</pre></div>
                  <div class="topic concept nested1" id="decoder-creation"><a name="decoder-creation" shape="rect">
                        <!-- --></a><h3 class="title topictitle2"><a href="#decoder-creation" name="decoder-creation" shape="rect">4.1.&nbsp;Decoder Creation</a></h3>
                     <div class="body conbody">
                        <div class="p">The sample application uses this API through a C++ Wrapper class
                           <samp class="ph codeph">VideoDecoder</samp> defined in <samp class="ph codeph">VideoDecoder.h</samp>. The
                           class’s constructor is a good starting point to see how to setup the
                           <samp class="ph codeph">CUVIDDECODECREATEINFO</samp> for the <samp class="ph codeph">cuvidCreateDecoder()</samp>
                           method. Most importantly, the create-info contains the following information about the
                           stream that’s going to be decoded: <a name="decoder-creation__ol_yhg_2r1_p3" shape="rect">
                              <!-- --></a><ol class="ol" id="decoder-creation__ol_yhg_2r1_p3">
                              <li class="li">codec-type</li>
                              <li class="li">the frame-size</li>
                              <li class="li">chroma format</li>
                           </ol>
                           
                           The user also determines various properties of the output that the decoder is to
                           generate: 
                           <ol class="ol">
                              <li class="li">Output surface format (currently only <dfn class="term">NV12</dfn> supported) 
                              </li>
                              <li class="li">Output frame size</li>
                              <li class="li">Maximum number of output surfaces. This is the maximum number of surfaces that
                                 the client code will simultaneously map for display.
                              </li>
                           </ol>
                           
                           The user also needs to specify the maximum number of surfaces the decoder may
                           allocate for decoding.
                        </div>
                     </div>
                  </div>
                  <div class="topic concept nested1" id="decoding-surfaces"><a name="decoding-surfaces" shape="rect">
                        <!-- --></a><h3 class="title topictitle2"><a href="#decoding-surfaces" name="decoding-surfaces" shape="rect">4.2.&nbsp;Decoding Surfaces</a></h3>
                     <div class="body conbody">
                        <p class="p">The decode sample application is driven by the <dfn class="term">VideoSource</dfn>
                           class (Windows only), which spawns its own thread. The source calls a
                           callback on the <dfn class="term">VideoParser</dfn> class (Windows only) to parse
                           the stream, the VideoParser in turn calls back into two callbacks that
                           handle the decode and display of the frames.  For Linux platforms, you
                           will need to write your own video source and parsing functions that
                           connect to the Video Decoding functions. 
                        </p>
                        <p class="p">The parser thread calls two callbacks to decode and display frames:</p><pre xml:space="preserve"><span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-comment">// Called by the video parser to decode a single picture. Since the parser will</span>
<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-comment">// deliver data as fast as it can, we need to make sure that the picture index</span>
<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-comment">// we're attempting to use for decode is no longer used for display.</span>
<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-keyword">static</span> <span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-keyword">int</span> CUDAAPI HandlePictureDecode(<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-keyword">void</span> *pUserData,
                                       CUVIDPICPARAMS *pPicParams);

<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-comment">// Called by the video parser to display a video frame (in the case of field</span>
<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-comment">// pictures, there may be two decode calls per one display call, since two</span>
<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-comment">// fields make up one frame).</span>
<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-keyword">static</span> <span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-keyword">int</span> CUDAAPI HandlePictureDisplay(<span xmlns:xslthl="http://xslthl.sf.net" class="xslthl-keyword">void</span> *pUserData,
                                        CUVIDPARSERDISPINFO *pPicParams);</pre><p class="p">The CUDA VideoParser passes a <samp class="ph codeph">CUVIDPICPARAMS</samp> struct to
                           the callback which can be passed straight on to the
                           <samp class="ph codeph">cuvidDecodePicture()</samp> function.  The
                           <samp class="ph codeph">CUVIDPICPARAMS</samp> struct contains all the information
                           necessary for the decoder to decode a frame or field; in particular
                           pointers to the video bitstream, information about frame size, flags if
                           field or frame, bottom or top field, etc. 
                        </p>
                        <p class="p">The decoded result gets associated with a picture-index value in the
                           <samp class="ph codeph">CUVIDPICPARAMS</samp> struct, which is also provided by the
                           parser. This picture index is later used to map the decoded frames to
                           cuda memory. 
                        </p>
                        <p class="p">The implementation of <samp class="ph codeph">HandlePictureDecode()</samp> in the
                           sample application waits if the output queue is full. When a slot in the
                           queue becomes available, it simply invokes the
                           <samp class="ph codeph">cuvidDecodePicture()</samp> function, passing the
                           <samp class="ph codeph">pPicParams</samp> as received from the parser.
                        </p>
                        <p class="p"><samp class="ph codeph">The HandlePictureDisplay()</samp> method is passed a
                           <samp class="ph codeph">CUVIDPARSERDISPINFO</samp> struct which contains the necessary
                           data for displaying a frame; i.e. the frame-index of the decoded frame
                           (as given to the decoder), and some information relevant for display like
                           frame-time, field, etc. The parser calls this method for frames in the
                           order as they should be displayed.
                        </p>
                        <p class="p">The implementation of <samp class="ph codeph">HandlePictureDisplay()</samp> method in
                           the sample application simply enqueues the <samp class="ph codeph">pPicParams</samp>
                           passed by the parser into the <dfn class="term">FrameQueue</dfn> object. 
                        </p>
                        <p class="p">The FrameQueue is used to implement a producer-consumer pattern passing
                           frames (or better, references to decoded frames) between the
                           VideoSource’s decoding thread and the application’s main thread, which is
                           responsible for their screen display.
                        </p>
                     </div>
                  </div>
                  <div class="topic concept nested1" id="processing-and-displaying-frames"><a name="processing-and-displaying-frames" shape="rect">
                        <!-- --></a><h3 class="title topictitle2"><a href="#processing-and-displaying-frames" name="processing-and-displaying-frames" shape="rect">4.3.&nbsp;Processing and Displaying Frames</a></h3>
                     <div class="body conbody">
                        <p class="p">The application’s main loop retrieves images from the <dfn class="term">FrameQueue</dfn>
                           (<samp class="ph codeph">copyDecodedFrameToTexture()</samp> in <samp class="ph codeph">videoDecode.cpp</samp>)
                           and renders the texture to the screen. The <dfn class="term">DirectX</dfn> device is set up to
                           block on monitor <dfn class="term">vsync</dfn>, throttling rendering to 60Hz for the typical
                           flat-screen display. To handle frame rate conversion of 3:2 pulldown content, we also
                           render the frame multiple-times, according to the repeat information passed from the
                           parser.
                        </p>
                        <p class="p"><samp class="ph codeph">copyDecodedFrameToTexture()</samp> is the method where the CUDA decoder API is
                           used to map a decoded frame (based on its <dfn class="term">Picture-Index</dfn>) into CUDA device
                           memory. 
                        </p>
                        <p class="p">Post processing on a frame is done by mapping the frame through
                           <samp class="ph codeph">cudaPostProcessFrame()</samp>. This returns a pointer to a
                           <dfn class="term">NV12</dfn> decoded frame. This then gets passed to a CUDA kernel to convert
                           NV12 surface to a <dfn class="term">RGBA</dfn> surface. The final RGBA surface is then copied
                           directly into a DirectX texture and then drawn to the screen.
                        </p>
                     </div>
                  </div>
                  <div class="topic concept nested1" id="performance-optimizations-for-video-decoding"><a name="performance-optimizations-for-video-decoding" shape="rect">
                        <!-- --></a><h3 class="title topictitle2"><a href="#performance-optimizations-for-video-decoding" name="performance-optimizations-for-video-decoding" shape="rect">4.4.&nbsp;Performance Optimizations for Video Decoding</a></h3>
                     <div class="body conbody">
                        <div class="p">The CUDA Samples (<samp class="ph codeph">cudaDecodeGL</samp> and <samp class="ph codeph">cudaDecodeD3D9</samp>) are
                           intended for simplicity and understanding of how to use this API case. It is by no means
                           a fully optimized application. This CUDA Video Decoder library makes use two different
                           engines on the GPU, the Video Processor and the Graphics hardware (CUDA and 3D). This
                           allows the Video Processor and the Graphics hardware to run asynchronously. The display
                           thread for this sample is this: 
                           <ol class="ol">
                              <li class="li"><samp class="ph codeph">cuvidMapVideoFrame</samp> – gets a CUDA device pointer from decoded
                                 frame of a Video Decoder (using map)
                              </li>
                              <li class="li"><samp class="ph codeph">cuD3D9ResourceGetMappedPointer</samp> – gets a CUDA device pointer
                                 from a D3D texture
                              </li>
                              <li class="li"><samp class="ph codeph">cudaPostProcessFrame</samp> – calls all subsequent CUDA post-process
                                 functions on that frame, and writes the result directly to the Mapped D3D
                                 texture.
                              </li>
                              <li class="li"><samp class="ph codeph">cuD3D9UnmapResources</samp> – driver will release pointer back to
                                 <dfn class="term">D3D9</dfn>. This tells the <dfn class="term">Direct3D</dfn> driver that CUDA is
                                 done modifying it, and that it is safe to use for D3D9.
                              </li>
                              <li class="li"><samp class="ph codeph">cuvidUnmapVideoFrame</samp> (Decoded Frame)
                              </li>
                           </ol>
                           
                           To improve performance, having 2 or more D3D9 or OpenGL surfaces to ping/pong can
                           improve performance. This enables the driver to schedule workload without blocking the
                           display thread. 
                        </div>
                     </div>
                  </div>
               </div>
               <div class="topic concept nested0" id="notices-header"><a name="notices-header" shape="rect">
                     <!-- --></a><h2 class="title topictitle1"><a href="#notices-header" name="notices-header" shape="rect">Notices</a></h2>
                  <div class="topic reference nested1" id="notice"><a name="notice" shape="rect">
                        <!-- --></a><h3 class="title topictitle2"><a href="#notice" name="notice" shape="rect"></a></h3>
                     <div class="body refbody">
                        <div class="section">
                           <h3 class="title sectiontitle">Notice</h3>
                           <p class="p">ALL NVIDIA DESIGN SPECIFICATIONS, REFERENCE BOARDS, FILES, DRAWINGS, DIAGNOSTICS, LISTS, AND OTHER DOCUMENTS (TOGETHER AND
                              SEPARATELY, "MATERIALS") ARE BEING PROVIDED "AS IS." NVIDIA MAKES NO WARRANTIES, EXPRESSED, IMPLIED, STATUTORY, OR OTHERWISE
                              WITH RESPECT TO THE MATERIALS, AND EXPRESSLY DISCLAIMS ALL IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTABILITY, AND FITNESS
                              FOR A PARTICULAR PURPOSE. 
                           </p>
                           <p class="p">Information furnished is believed to be accurate and reliable. However, NVIDIA Corporation assumes no responsibility for the
                              consequences of use of such information or for any infringement of patents or other rights of third parties that may result
                              from its use. No license is granted by implication of otherwise under any patent rights of NVIDIA Corporation. Specifications
                              mentioned in this publication are subject to change without notice. This publication supersedes and replaces all other information
                              previously supplied. NVIDIA Corporation products are not authorized as critical components in life support devices or systems
                              without express written approval of NVIDIA Corporation.
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="topic reference nested1" id="trademarks"><a name="trademarks" shape="rect">
                        <!-- --></a><h3 class="title topictitle2"><a href="#trademarks" name="trademarks" shape="rect"></a></h3>
                     <div class="body refbody">
                        <div class="section">
                           <h3 class="title sectiontitle">Trademarks</h3>
                           <p class="p">NVIDIA and the NVIDIA logo are trademarks or registered trademarks of NVIDIA Corporation
                              in the U.S. and other countries.  Other company and product names may be trademarks of
                              the respective companies with which they are associated.
                           </p>
                        </div>
                     </div>
                  </div>
                  <div class="topic reference nested1" id="copyright-past-to-present"><a name="copyright-past-to-present" shape="rect">
                        <!-- --></a><h3 class="title topictitle2"><a href="#copyright-past-to-present" name="copyright-past-to-present" shape="rect"></a></h3>
                     <div class="body refbody">
                        <div class="section">
                           <h3 class="title sectiontitle">Copyright</h3>
                           <p class="p">© <span class="ph">2012</span>-<span class="ph">2017</span> NVIDIA
                              Corporation. All rights reserved.
                           </p>
                           <p class="p">This product includes software developed by the Syncro Soft SRL (http://www.sync.ro/).</p>
                        </div>
                     </div>
                  </div>
               </div>
               
               <hr id="contents-end"></hr>
               
            </article>
         </div>
      </div>
      <script language="JavaScript" type="text/javascript" charset="utf-8" src="../common/formatting/common.min.js"></script>
      <script language="JavaScript" type="text/javascript" charset="utf-8" src="../common/scripts/google-analytics/google-analytics-write.js"></script>
      <script language="JavaScript" type="text/javascript" charset="utf-8" src="../common/scripts/google-analytics/google-analytics-tracker.js"></script>
      <script type="text/javascript">var switchTo5x=true;</script><script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script><script type="text/javascript">stLight.options({publisher: "998dc202-a267-4d8e-bce9-14debadb8d92", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script></body>
</html>